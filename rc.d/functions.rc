# Runtime functions

# git diff HEAD <X>  where X is 1 by default
gdfhx() {
	if [ -z "$1" ]; then
		X=1
	else
		X="$1"
	fi
	git diff HEAD~$X
}

mcd() {
	DIRPATH="$1"
	mkdir -p $DIRPATH && cd $DIRPATH
}

# quickly tweak rc shell configs
# useage: rce <config file flag>
# config file flags: {a: alias} {e: exports} {f: functions} {i: idea}
rce() {
	RC_DIR="/home/nukk/git/ongoing/newdots/rc.d/"
	# TODO: convert to CASE statement
	if [[ -z "$1" ]]; then
		vim "$RC_DIR"
	elif [[ "$1" = "a" ]]; then
		vim "$RC_DIR/aliases.rc"
	elif [[ "$1" = "e" ]]; then
		vim "$RC_DIR/exports.rc"
	elif [[ "$1" = "f" ]]; then
		vim "$RC_DIR/functions.rc"
	elif [[ "$1" = "c" ]]; then
		vim "$RC_DIR/configd.rc"
	elif [[ "$1" = "i" ]]; then
		vim "$RC_DIR/ideas.rc"
	else
		echo "Error"
	fi
}

# TODO: make version of this to quickly select folder to save existing file
# TODO Example:  <quick save function> <file> ->> brings up fzf prompt and from FZF prompt destination location selected ->> script saves <file> at <fzf selected dir>

# TODO: integrate FZF so file can be saved from FZF selection instead of location from predefined array
# quickly add tmp file to one of handful locations
# useage: tmpp <config file flag>
# config file flags: {a: archive} {d: dump} {n: note} {s: sandbox}  {u: unsorted}
tmpp() {
	TMP_DIR="$HOME/quick/tmp"
	# TODO: convert to CASE statement
	if [[ -z "$1" ]]; then
		vim "$TMP_DIR/quick-$(date +%Y%M%D-%H%M%S).md"

	elif [[ "$1" = "a" ]]; then
		TMP_DIR="$TMP_DIR/archive"

	elif [[ "$1" = "d" ]]; then
		TMP_DIR="$TMP_DIR/data/"

	elif [[ "$1" = "n" ]]; then
		TMP_DIR="$TMP_DIR/notes"

	elif [[ "$1" = "s" ]]; then
		TMP_DIR="$TMP_DIR/sandboxes"

	elif [[ "$1" = "u" ]]; then
		TMP_DIR="$TMP_DIR/unsorted"
	else
		echo "Error"
	fi
	vim "$TMP_DIR/quick-$(date +%Y%m%d-%H%M%S).md"
}

venvfreeze() {

	# constants
	LOCAL_VENV_HOME="$XDG_STATE_HOME/python/virtualEnvs"
	CURRENT_VENV_DIR="$(which python3 | sed -E 's/\/bin.+$//g')"
	VENV_NAME="$(basename $CURRENT_VENV_DIR)"

	# gracefully deactivate
	pip freeze | tee $CURRENT_VENV_DIR/requirements.txt
	ln -sf "$CURRENT_VENV_DIR/requirements.txt" "$LOCAL_VENV_HOME/requirements/$VENV_NAME.requirements.txt"
	deactivate
}

# TODO: finish building - need to figure out if rc.d files will get their own flag or if they will be included in single "bundle" flag
# arg map: {z:zshrc} {l:lunarvim} {r:rcdirs?}
# must pass at least 1 args

source_dotfile() {
	# check arg, and depending on arg source relevant file(s)
	echo "Work in progress"
}

# create new test/sandbox folder
# 2 optional arg:
#   1: name of test dir
#   2: cd flag ("y" means, yes cd to newly created dir)
mk_testdir() {
	TEST_HOME_DIR="$HOME/.local/tmp/tests"
	TEST_TEMPLATE_NAME="template1"
	TEST_TEMPLATE_DIRPATH="$TEST_HOME_DIR/$TEST_TEMPLATE_NAME"
	if [[ -n "$1" ]]; then
		NEW_DIR_NAME="$1"
	else
		NEW_DIR_NAME="test-$(date +%Y%m%d_%H%M%S)"
	fi

	# copy template and if "cd" flag enabled cd into new dir
	cp -r $TEST_TEMPLATE_DIRPATH $TEST_HOME_DIR/$NEW_DIR_NAME
	echo "cp -rv   $TEST_TEMPLATE_DIRPATH $TEST_HOME_DIR/$NEW_DIR_NAME"
	test "$2" = "y" && cd $TEST_HOME_DIR/$NEW_DIR_NAME
}

# quickly spinup new venvs
function venvmake() {

	if [ -z "$1" ]; then
		echo "Error, no venv name argument given."
		exit 1
	else
		NAME="$1"
	fi

	# ensure no venvs enabled
	if [[ "$(which python3 | grep -Ec --ignore-case "virtualenv|venv")" -ge 1 ]]; then
		echo "which result: $(which python3)"
		deactivate
	else
		echo "No virtual env. enabled, skipping deactivation step."
	fi

	# make venv path
	LOCAL_VENVS_DIR="$XDG_STATE_HOME/python/virtualEnvs"
	NEW_VENV_PATH="$LOCAL_VENVS_DIR/$NAME"

	# make venv
	python3 -m venv $NEW_VENV_PATH

	# turn on newly created venv
	source "$NEW_VENV_PATH/bin/activate"

	# TODO: add logic to handle requirements.txt arg
	# TODO: add logic to pipstall requirements file if present

	echo ""
	echo "Trial Function: Make VENV Automateer"
}

# dump either urser text string or url to master dumpfile (not suited for anything more complex than single string)
quickdump() {
	# variables
	DUMPFILE="$$HOME/git/fortknox/knowledge_dumpfile_master.md"
	BACKUPFILE="$HOME/.local/session/quickdumps/master_dumpfile.bk"
	DUMPTEXT="$1"

	# smart copy
	cp $DUMPFILE $BACKUPFILE
	echo "" >>$DUMPFILE
	echo "$DUMPTEXT" >>DUMPFILE
}

# mkdir+cd
mcd() {
	mkdir $1 -p
	cd $1
}

ssh-cacher() {
	eval $(ssh-agent) && ssh-add "$HOME/.ssh/id_rsa"
}

## ====================================
##  HELPER FUNCTIONS
## ====================================

# FZF branch checkout tool
gcof() {
	# verbose flag passed, needed for checking origin/<BRANCH>
	if [[ $1 = "v" ]]; then
		echo "Verbose flag passed, included origin/remote branches as well."
		echo ""
		git branch -va | awk -F' ' '{print $1}' | rg -v "\*" |
			fzf -1 | awk -F 'remotes/' '{print $2}' |
			xargs -I "{}" git checkout "{}"

	else
		echo "No flag passed, only local branches will be used."
		git branch -v | awk -F' ' '{print $1}' | rg -v "\*" |
			fzf -1 | xargs -I "{}" git checkout "{}"
	fi
}

# @TODO - add nvim/kickstart/git[ignore/config] handling
# edit dotfiles (each maps to dotfile tech)
# args: z,v,k,n,t,gi,gc,b
edot() {

	# validate input
	if [[ -z "$1" ]]; then
		echo "Error - required argument missing."
		exit 1
	fi

	case $1 in
	# bashrc
	b)
		echo "BASHRC argument passed"
		vim "$HOME/.bashrc"
		;;
	t)
		echo "TMUX.CONF argument passed"
		vim "$HOME/.tmux.conf"
		;;
	v)
		echo "VIMRC argument passed"
		vim "$HOME/.vimrc"
		;;
	z)
		echo "TMUX.CONF argument passed"
		vim "$HOME/.zshrc"
		;;
	*)
		echo "Required argument missing. Valid arguments are b, t, v, z."
		;;
	esac

}

## =============================================
## ON-THE-FLY DOTFILE EDITING FUNCTION
## =============================================

edf() {

	# function must be given an ARG when called
	# ARG must map to one of the below "file flags"
	#
	# function edits:
	#   - bashrc (b)
	#   - bashrc_wsl (bw)
	#   - vimrc (v)
	#   - vim_lib (vl)
	#   - init.lua (n)
	#   - neovim lsp (nl)
	#   - neovim plugins (np)
	#   - neovim opts (no)
	#   - neovim keymaps (nk)
	#   - tmux.conf (t)
	#   - gitconfig (g)

	# DOTFILE path depends on host machine
	if [[ "$(echo $HOSTNAME | egrep -ci 'DESKTOP')" -ge 1 ]]; then
		DOTFILE_HOME_DIR="$HOME/dotfiles"
		echo "Current session is running on my Local machine - $HOSTNAME"
	else
		DOTFILE_HOME_DIR="$HOME/dotfiles"
	fi
	echo "DOTFILE_HOME_DIR:  $DOTFILE_HOME_DIR"

	case $1 in
	b)
		vim "$DOTFILE_HOME_DIR/bash.d/bashrc"
		;;
	bw)
		vim "$DOTFILE_HOME_DIR/bash.d/bashrc_wsl"
		;;
	t)
		vim "$DOTFILE_HOME_DIR/tmux.d/tmux.conf"
		;;
	g)
		vim "$DOTFILE_HOME_DIR/git.d/gitconfig"
		;;
	ni)
		vim "$DOTFILE_HOME_DIR/nvim.d/init.lua"
		;;
	no)
		vim "$DOTFILE_HOME_DIR/nvim.d/lua/user/opts.lua"
		;;
	nk)
		vim "$DOTFILE_HOME_DIR/nvim.d/lua/user/keymaps.lua"
		;;
	np)
		vim "$DOTFILE_HOME_DIR/nvim.d/lua/plugins"
		;;
	nl)
		vim "$DOTFILE_HOME_DIR/nvim.d/lua/extra/lsp.lua"
		;;
	v)
		vim "$DOTFILE_HOME_DIR/vim.d/vimrc"
		;;
	vl)
		vim "$DOTFILE_HOME_DIR/vim.d/vim_lib"
		;;
	**)
		echo 'Unrecognized $ARG passed'
		;;
	esac
}

## qxs - (Q)ui(X) (S)cratch file genertor
qxs() {

	# function must be given an ARG when called
	# ARG must map to one of the below scratch "file flags"
	#
	# function edits:
	#   - bash sandbox (b)
	#   - python sandbox (p)
	#   - dotfiles sandbox (d)
	#   - sql sandbox (s)
	#   - testing sandbox ()
	#   - junk sandbox (j)      ## @TODO - create script to auto remove files from folder after X time (> 1 week)
	#   - git sandbox (g)
	#   - written txt/markdown notes (w)   ## 'w' for written, use 'h' for human/help if 'w' taken
	#

	## variables
	SANDBOXES_HOME_DIR="$HOME/.local/var/temp/sandboxes"
	TEXTFILES_HOME_DIR="$HOME/git/kb2/quick/autostash" # diff location for written notes/docs

	mkdir -p $SANDBOXES_HOME_DIR

	# set EDITOR to vim as fallback if DNE
	#[ -z "$EDITOR" ] && EDITOR=vim

	#    # scalably add/remove/modify variables dirpaths
	#    VAR_LIST=($SANDBOXES_HOME_DIR $TEXTFILES_HOME_DIR)
	#    for varx in ${VAR_LIST[@]}; do
	#        [[ -d "$varx" ]] || mkdir -p "$varx"
	#        mkdir -p $varx
	#    done

	## make subdirs first
	SUBDIRS=(bash python dotfiles git sql junk testing all)
	for sd in ${SUBDIRS[@]}; do
		mkdir -p "$SANDBOXES_HOME_DIR/$sd"
		echo mkdir -p "$SANDBOXES_HOME_DIR/$sd"
	done

	# @TODO - Add upper/lower case variations to CASE statement for existing flags
	# @TODO - Add separate logic for reopening recent/existing scratch file use case
	# create scratchfile from CASE statement flag input
	case "$1" in

	b | B | bash | sh | shell)
		echo -n "Bash/Shell sandbox FLAG passed"
		mkdir -p "$SANDBOXES_HOME_DIR/bash"
		$EDITOR "$SANDBOXES_HOME_DIR/bash/bash_scratch_$(date +%Y%m%d-%H%M%S).sh"
		;;

	p | P | python)
		echo -n "Python sandbox FLAG passed"
		mkdir -p "$SANDBOXES_HOME_DIR/python"
		$EDITOR "$SANDBOXES_HOME_DIR/python/python_scratch_$(date +%Y%m%d-%H%M%S).py"
		;;

	d | dotfiles)
		echo -n "Dotfile sandbox FLAG passed. Append extension manually if filetype extention needed."
		mkdir -p "$SANDBOXES_HOME_DIR/dotfiles"
		$EDITOR "$SANDBOXES_HOME_DIR/dotfiles/dotfile_scratch_$(date +%Y%m%d-%H%M%S).dotfile"
		;;

	g | git)
		echo -n "Git sandbox FLAG passed"
		mkdir -p "$SANDBOXES_HOME_DIR/git"
		$EDITOR "$SANDBOXES_HOME_DIR/git/git_scratch_$(date +%Y%m%d-%H%M%S).git"
		;;

	j | junk | temp | tmp | quick | q | J)
		echo -n "Junk/Quick/Temp sandbox FLAG passed. Append extension manually if filetype extention needed."
		mkdir -p "$SANDBOXES_HOME_DIR/junk"
		$EDITOR "$SANDBOXES_HOME_DIR/junk/junk_scratch_$(date +%Y%m%d-%H%M%S).junk"
		;;

	t | test | explore | experiment | exp)
		echo -n "Test/Experiment/Explore sandbox FLAG passed. Append extension manually if filetype extention needed."
		mkdir -p "$SANDBOXES_HOME_DIR/testing"
		$EDITOR "$SANDBOXES_HOME_DIR/testing/test_scratch_$(date +%Y%m%d-%H%M%S).test"
		;;

	s | sql)
		echo -n " sandbox FLAG passed"
		mkdir -p "$SANDBOXES_HOME_DIR/sql"
		$EDITOR "$SANDBOXES_HOME_DIR/sql/sql_scratch_$(date +%Y%m%d-%H%M%S).sql"
		;;

	w | h)
		echo -n "Written/Help FLAG passed"
		mkdir -p "$TEXTFILES_HOME_DIR/qxs"
		$EDITOR "$TEXTFILES_HOME_DIR/qxs/doc_scratch_$(date +%Y%m%d-%H%M%S).md"
		;;

	*)
		echo -n "Unknown/Unspecified which defaults to ALL"
		mkdir -p "$SANDBOXES_HOME_DIR/all"
		$EDITOR "$SANDBOXES_HOME_DIR/all/all_scratch_$(date +%Y%m%d-%H%M%S).all"
		;;
	esac
}

mk_venv() {
	VENV_NAME="$1"
	VENV_PREFIX="venv"
	VENV_NEW="$VENV_PREFIX-$VENV_NAME"
	VENV_HOME_DIR="$HOME/.local/state/python/venvs/"

	# disable Venv if enabled
	if [[ $(which python3 | egrep -c "state.+venvs") -ge 1 ]]; then
		deactivate
	fi

	# check for existing safeguards
	if [[ ! -d $VENV_HOME_DIR ]]; then
		mkdir -p $VENV_HOME_DIR

	# source existing if present
	elif [[ -d $VENV_NEW ]]; then
		echo "A virtual env. named $VENV_NEW already exists and will be sourced instead"
		source $VENV_NEW/bin/activate

	# otherwise create Venv
	else
		cd $VENV_HOME_DIR
		python3 -m venv "$VENV_NEW"
		source $VENV_NEW/bin/activate
		cd -
	fi

}
